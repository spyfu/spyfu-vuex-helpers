{"version":3,"file":"spyfu-vuex-helpers.js","sources":["../lib/helpers/assign_state.js","../lib/helpers/find_instance_then.js","../lib/helpers/instance_getters.js","../lib/helpers/instance_mutations.js","../lib/helpers/utils/get_entries.js","../lib/helpers/utils/compose.js","../lib/helpers/utils/key_value_to_object.js","../lib/helpers/map_instance_getters.js","../lib/helpers/utils/parsers.js","../lib/helpers/utils/resolve_object_path.js","../lib/helpers/map_instance_state.js","../lib/helpers/utils/error.js","../lib/helpers/map_two_way_state.js","../lib/helpers/simple_instance_setters.js","../lib/helpers/simple_pushers.js","../lib/helpers/simple_removers.js","../lib/helpers/simple_setters.js"],"sourcesContent":["/**\n * Mutation to set the entire state of a module.\n * \n * @param  {Function}   stateFactory    a function that returns a fresh state object\n * @return {Function}\n */\nexport default function (stateFactory) {\n    return function (state) {\n        Object.assign(state, stateFactory());\n    }\n}","/**\r\n * Find a state instance, and execute a callback if found.\r\n *\r\n * @param  {Object|Function}    required    the config object, or mutation callback\r\n * @param  {Function}           optional    mutation callback\r\n * @return {Function}\r\n */\r\nconst findInstanceThen = function () {\r\n    // this function supports two argument signatures. if the\r\n    // first argument is an object, we will use that as the\r\n    // config, and the second arg as the mutation handler\r\n    const { config, callback } = parseArguments(arguments);\r\n\r\n    return (state, payload) => {\r\n        if (stateAndPayloadAreValid(config, state, payload)) {\r\n\r\n            // find our instance based on the current configuration\r\n            const instance = state[config.stateKey].find(obj => {\r\n                return obj[config.instanceKey] === payload[config.instanceKey];\r\n            });\r\n\r\n            // if the instance was found, execute our mutation callback\r\n            if (instance) {\r\n                callback(instance, payload, state);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// this method allows us to easily apply configuration to the helper\r\nfindInstanceThen.config = opts => findInstanceThen.bind(null, opts);\r\n\r\n// helper to get config and callback from the arguments\r\nfunction parseArguments(args) {\r\n    let defaultConfig = {\r\n        stateKey: 'instances',\r\n        instanceKey: 'id',\r\n    };\r\n\r\n    if (typeof args[0] === 'function') {\r\n        return {\r\n            callback: args[0],\r\n            config: defaultConfig,\r\n        }\r\n    } else {\r\n        return {\r\n            callback: args[1],\r\n            config: Object.assign({}, defaultConfig, args[0]),\r\n        };\r\n    }\r\n}\r\n\r\n// check if the state or payload is malformed\r\nfunction stateAndPayloadAreValid(config, state, payload) {\r\n\r\n    // ensure that the instances array exists\r\n    if (! Array.isArray(state[config.stateKey])) {\r\n        console.error(`State does not contain an \"${ config.stateKey }\" array.`);\r\n        return false;\r\n    }\r\n\r\n    // ensure that the payload contains an id\r\n    if (typeof payload !== 'object' || typeof payload[config.instanceKey] === 'undefined') {\r\n        console.error(`Mutation payloads must be an object with an \"${ config.instanceKey }\" property.`);\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nexport default findInstanceThen;\r\n","\r\n/**\r\n * Instance getters.\r\n *\r\n * @return {Object}\r\n */\r\nexport default function() {\r\n    const { getters, options } = parseArguments(arguments);\r\n\r\n    return Object.keys(getters).reduce((instanceGetters, name) => {\r\n        instanceGetters[name] = (state, otherGetters) => instanceKey => {\r\n            const instance = state[options.stateKey || 'instances'].find(obj => {\r\n                return obj[options.instanceKey || 'id'] === instanceKey;\r\n            });\r\n\r\n            if (instance) {\r\n                return getters[name](instance, otherGetters, state, instanceKey);\r\n            }\r\n        };\r\n\r\n        return instanceGetters;\r\n    }, {});\r\n}\r\n\r\n// parse arguments\r\nfunction parseArguments(args) {\r\n    const hasOptionsArg = args.length > 1;\r\n\r\n    return {\r\n        options: hasOptionsArg ? args[0] : {},\r\n        getters: hasOptionsArg ? args[1] : args[0],\r\n    };\r\n}\r\n","import findInstanceThen from './find_instance_then';\r\n\r\n/**\r\n * Instance mutations.\r\n *\r\n * @return {Object}\r\n */\r\nexport default function() {\r\n    const { options, mutations } = parseArguments(arguments);\r\n\r\n    return Object.keys(mutations).reduce((instanceMutations, name) => {\r\n        instanceMutations[name] = findInstanceThen(options, mutations[name]);\r\n\r\n        return instanceMutations;\r\n    }, {});\r\n}\r\n\r\n// parse arguments\r\nfunction parseArguments(args) {\r\n    const hasOptionsArg = args.length > 1;\r\n\r\n    const defaultOptions = {\r\n        stateKey: 'instances',\r\n        instanceKey: 'id',\r\n    };\r\n\r\n    return {\r\n        options: hasOptionsArg ? args[0] : defaultOptions,\r\n        mutations: hasOptionsArg ? args[1] : args[0],\r\n    };\r\n}\r\n","// Similar to Object.entries but without using polyfill\r\nexport default function (obj) {\r\n    return Object.keys(obj).map(key => [ key, obj[key] ]);\r\n}\r\n","// Function to compose other functions (right to left evaluation)\r\nexport default function () {\r\n    const fns = arguments;\r\n\r\n    return function () {\r\n        let result;\r\n        \r\n        for (let i = fns.length - 1; i > -1; i--) {\r\n            if (i === fns.length - 1) {\r\n                result = fns[i].apply(fns[i], arguments);\r\n            } else {\r\n                result = fns[i].call(this, result);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n}\r\n","// Convert KeyValuePair[] to Object\r\nexport default function (obj, keyValuePair) {\r\n    const [ key, value ] = keyValuePair;\r\n    obj[key] = value;\r\n\r\n    return obj;\r\n}\r\n","import { mapGetters } from 'vuex';\r\nimport getEntries from './utils/get_entries';\r\nimport compose from './utils/compose';\r\nimport toObject from './utils/key_value_to_object';\r\n\r\n// Create a wrapper function which invokes the original function\r\n// passing in `this.id`\r\nconst wrapGetterFn = ([ key, originalFn ]) => {\r\n    const newFn = function () {\r\n        const innerFn = originalFn.apply(this, arguments);\r\n\r\n        if (typeof innerFn !== 'function') {\r\n            /* istanbul ignore next */\r\n            throw `The getter ${key} does not return a function. Try using the 'mapGetter' helper instead`;\r\n        }\r\n        \r\n        return innerFn(this.id);\r\n    };\r\n\r\n    return [ key, newFn ];\r\n};\r\n\r\nfunction invokeGettersWithId (getters) {\r\n    return getEntries(getters)\r\n        .map(wrapGetterFn)\r\n        .reduce(toObject, {});\r\n}\r\n\r\nconst mapInstanceGetters = compose(invokeGettersWithId, mapGetters);\r\n\r\nexport default mapInstanceGetters;\r\n","export function parseMappingArguments(args) {\r\n    // namespace is optional\r\n    const namespace = typeof args[0] === 'string' ? args[0] : null;\r\n\r\n    // mappings are required\r\n    const mappings = namespace ? args[1] : args[0];\r\n\r\n    // by default, the vm identifier key will be 'id'\r\n    const vmIdentifierKey = (namespace ? args[2] : args[1]) || 'id';\r\n\r\n    // by default, the instance identifier will be 'id'\r\n    const stateKey = 'instances';\r\n\r\n    // by default, the state key will be 'instances'\r\n    const instanceIdentifierKey = 'id';\r\n\r\n    return {\r\n        namespace,\r\n        mappings,\r\n        vmIdentifierKey,\r\n        instanceIdentifierKey,\r\n        stateKey,\r\n     };\r\n}\r\n","/**\r\n * Helper function for resolving nested object values.\r\n *\r\n * @param  {Object}         obj         source object\r\n * @param  {Array|String}   path        path to nested value\r\n * @param  {String|RegExp}  delimeter   characters / pattern to split path on\r\n * @return {mixed}\r\n */\r\nexport default function(obj, path, delimeter = '.') {\r\n    const pathArray = Array.isArray(path) ? path : path.split(delimeter);\r\n\r\n    return pathArray.reduce((p, item) => p && p[item], obj);\r\n}\r\n","import { parseMappingArguments } from './utils/parsers';\r\nimport resolveObjectPath from './utils/resolve_object_path';\r\n\r\nexport default function() {\r\n    // extract our namespace and mappings from the arguments\r\n    const {\r\n        namespace,\r\n        mappings,\r\n        vmIdentifierKey,\r\n        instanceIdentifierKey,\r\n        stateKey,\r\n    } = parseMappingArguments(arguments);\r\n\r\n    // normalize our mappings\r\n    const normalizedMappings = normalizeMappings(mappings);\r\n\r\n    // create a getter for each mapped piece of state\r\n    const computedProperties = {};\r\n\r\n    Object.keys(normalizedMappings).forEach((key) => {\r\n        const computedKey = key.split('.').pop();\r\n\r\n        computedProperties[computedKey] = createGetter({\r\n            key,\r\n            namespace,\r\n            normalizedMappings,\r\n            vmIdentifierKey,\r\n            instanceIdentifierKey,\r\n            stateKey,\r\n        });\r\n    });\r\n\r\n    return computedProperties;\r\n}\r\n\r\n// normalize the mappings into a consistent object format\r\nfunction normalizeMappings(mappings) {\r\n    if (Array.isArray(mappings)) {\r\n        return mappings.reduce((normalizedMappings, key) => {\r\n            normalizedMappings[key] = key;\r\n\r\n            return normalizedMappings;\r\n        }, {});\r\n    }\r\n\r\n    return mappings;\r\n}\r\n\r\n// create a getter for a particular piece of state\r\nfunction createGetter({ key, namespace, normalizedMappings, vmIdentifierKey, instanceIdentifierKey, stateKey }) {\r\n    return function() {\r\n        // find the state object\r\n        const state = namespace\r\n            ? resolveObjectPath(this.$store.state, namespace, '/')\r\n            : this.$store.state;\r\n\r\n        // find our container of instances\r\n        const instancesContainer = resolveObjectPath(state, stateKey, '.');\r\n\r\n        // find our instance within it\r\n        const instance = instancesContainer.find(obj => obj[instanceIdentifierKey] === this[vmIdentifierKey]);\r\n\r\n        // and if all goes well, resolve the piece of state we're looking for\r\n        if (instance) {\r\n            return typeof normalizedMappings[key] === 'function'\r\n                ? normalizedMappings[key](instance)\r\n                : resolveObjectPath(instance, normalizedMappings[key]);\r\n        }\r\n    }\r\n}\r\n","// helper to throw consistent errors\r\n// this is useful in testing to make sure caught errors are ours\r\nexport default function(message, ...args) {\r\n    throw new Error('[spyfu-vuex-helpers]: ' + message, ...args);\r\n}","import resolveObjectPath from './utils/resolve_object_path';\r\nimport error from './utils/error';\r\n\r\n/**\r\n * Map vuex state with two way computed properties\r\n *\r\n * @param  {string|Object}  required the module namespace, or state mappings\r\n * @param  {Object}         optional state mappings\r\n * @return {Object}\r\n */\r\nexport default function () {\r\n    // this function supports two argument signatures. if the\r\n    // first argument is a string, we will use that as the\r\n    // namespace, and the next arg as the state mapping\r\n    const { namespace, mappings } = parseArguments(arguments);\r\n\r\n    // then get the key and mutation names from our mappings\r\n    const parsedMappings = parseMappings(mappings);\r\n\r\n    // and last, turn them into getters and setters\r\n    const computedProperties = {};\r\n\r\n    Object.keys(parsedMappings).forEach((key) => {\r\n        computedProperties[key] = {\r\n            get: createGetter(namespace, parsedMappings[key]),\r\n            set: createSetter(namespace, parsedMappings[key]),\r\n        };\r\n    });\r\n\r\n    return computedProperties;\r\n}\r\n\r\n// determine the values of our namespace and mappings\r\nfunction parseArguments(args) {\r\n    const first = args[0];\r\n    const second = args[1];\r\n\r\n    return typeof first === 'string'\r\n        ? { namespace: first, mappings: second }\r\n        : { namespace: null, mappings: first };\r\n}\r\n\r\n// determine our key and mutation values\r\nfunction parseMappings(obj) {\r\n    const mapping = {};\r\n\r\n    // throw a helpful error when mapTwoWayState is mixed up with mapState\r\n    if (Array.isArray(obj)) {\r\n        error('Invalid arguments for mapTwoWayState. State mapping must be an object in { \\'path.to.state\\': \\'mutationName\\' } format.');\r\n    }\r\n\r\n    Object.keys(obj).forEach((key) => {\r\n        const value = obj[key];\r\n        const vmKey = key.slice(key.lastIndexOf('.') + 1);\r\n\r\n        if (typeof value === 'string') {\r\n            mapping[vmKey] = { key, mutation: value };\r\n        } else {\r\n            mapping[vmKey] = { key: value.key, mutation: value.mutation };\r\n        }\r\n    });\r\n\r\n    return mapping;\r\n}\r\n\r\n// create a getter for computed properties\r\nfunction createGetter(namespace, mapping) {\r\n    if (namespace) {\r\n        return function () {\r\n            const state = resolveObjectPath(this.$store.state, namespace, '/');\r\n\r\n            return resolveObjectPath(state, mapping.key, '.');\r\n        };\r\n    }\r\n\r\n    return function () {\r\n        return resolveObjectPath(this.$store.state, mapping.key, '.');\r\n    };\r\n}\r\n\r\n// create a setter for computed properties\r\nfunction createSetter(namespace, mappings) {\r\n    let mutation = mappings.mutation;\r\n\r\n    if (namespace) {\r\n        mutation = namespace + '/' + mutation;\r\n    }\r\n\r\n    return function (value) {\r\n        this.$store.commit(mutation, value)\r\n    };\r\n}\r\n","import resolveObjectPath from './utils/resolve_object_path';\r\n\r\n/**\r\n * Simple mutations that set an instance's state equal to a value.\r\n *\r\n * @param  {Object}\r\n * @param  {String}\r\n * @param  {String}\r\n * @return {Object}\r\n */\r\nexport default function(\r\n    setters,\r\n    stateKey = 'instances',\r\n    instanceKey = 'id'\r\n) {\r\n    // loop over the setter keys and make a mutation for each\r\n    return Object.keys(setters).reduce((mutations, name) => {\r\n\r\n        // attach our new mutation to result\r\n        return Object.assign({}, mutations, {\r\n            [name](state, payload) {\r\n                // find the instance that we're mutating\r\n                const instance = findInstance(state, stateKey, instanceKey, payload);\r\n\r\n                if (instance) {\r\n                    const value = findValue(payload, instanceKey);\r\n\r\n                    // if the setter name has a dot, then resolve the\r\n                    // state path before feeding our value into it.\r\n                    if (setters[name].indexOf('.') > -1) {\r\n                        const obj = setters[name].split('.');\r\n                        const key = obj.pop();\r\n\r\n                        resolveObjectPath(instance, obj)[key] = value;\r\n                    } else {\r\n                        // otherwise, just set the instance state to our value\r\n                        instance[setters[name]] = value;\r\n                    }\r\n                } else {\r\n                    // if the instance wasn't found, let the dev know with a warning\r\n                    console.warn (`An instance with an identifier of ${instanceKey} was not found.`);\r\n                }\r\n            },\r\n        });\r\n    }, {});\r\n}\r\n\r\n// helper function to find the correct instance\r\nfunction findInstance(state, stateKey, instanceKey, payload) {\r\n    return state[stateKey].find(obj => obj[instanceKey] === payload[instanceKey]);\r\n}\r\n\r\n// helper function to find the payload value\r\nfunction findValue(payload, instanceKey) {\r\n    for (let key in payload) {\r\n        if (key !== instanceKey) {\r\n            return payload[key];\r\n        }\r\n    }\r\n\r\n    // if we don't have a value, throw an error because the payload is invalid.\r\n    /* istanbul ignore next */\r\n    throw new Error('Failed to mutate instance, no value found in payload.', payload);\r\n}\r\n","import error from './utils/error';\r\nimport resolveObjectPath from './utils/resolve_object_path';\r\n\r\n/**\r\n * Simple mutations pushes values onto an array.\r\n *\r\n * @param  {Object} pushers Object mapping mutations to state\r\n * @return {Object}\r\n */\r\nexport default function(pushers) {\r\n    return Object.keys(pushers).reduce((mutations, name) => {\r\n        return {\r\n            ...mutations,\r\n            [name](state, value) {\r\n                const mutationName = pushers[name];\r\n\r\n                // if the pusher name has a dot, then resolve the\r\n                // array path before pushing our value onto it\r\n                if (mutationName.indexOf('.') > -1) {\r\n                    const obj = mutationName.split('.');\r\n                    const key = obj.pop();\r\n                    const parentObj = resolveObjectPath(state, obj);\r\n\r\n                    // dev errors\r\n                    if (process.env.NODE_ENV !== 'production') {\r\n                        // target path must resolve to an array\r\n                        if (!parentObj || typeof parentObj[key] === 'undefined') {\r\n                            error(`simplePusher mutation failed, target \"${mutationName}\" is undefined.`);\r\n                        } else if (!Array.isArray(parentObj[key])) {\r\n                            error(`simplePusher mutation failed, target \"${mutationName}\" is not an array, ${typeof parentObj[key]} found.`);\r\n                        }\r\n                    }\r\n                    \r\n                    parentObj[key].push(value);\r\n                }\r\n\r\n                // otherwise, just push our value onto the array\r\n                else {\r\n\r\n                    // dev errors\r\n                    if (process.env.NODE_ENV !== 'production') {\r\n                        // target must be an array\r\n                        if (typeof state[mutationName] === 'undefined') {\r\n                            error(`simplePusher mutation failed, target \"${mutationName}\" is undefined.`);\r\n                        } else if (!Array.isArray(state[mutationName])) {\r\n                            error(`simplePusher mutation failed, target \"${mutationName}\" is not an array, ${typeof state[mutationName]} found.`);\r\n                        }\r\n                    }\r\n\r\n                    state[mutationName].push(value);\r\n                }\r\n            },\r\n        }\r\n    }, {});\r\n}","/* eslint-disable */\nimport error from './utils/error';\nimport resolveObjectPath from './utils/resolve_object_path';\n\n/**\n * Simple mutations that removes a value from an array.\n *\n * @param  {Object} removers     Object mapping mutations to state\n * @return {Object}\n */\nexport default function(removers) {\n    // loop over the setter keys and make a mutation for each\n    return Object.keys(removers).reduce((mutations, name) => {\n\n        // attach our new mutation to result\n        return Object.assign({}, mutations, {\n            [name](state, removeVal) {\n                const mutationName = removers[name];\n\n                // if the target has a dot, remove our value from the nested array\n                if (mutationName.indexOf('.') > -1) {\n                    const obj = removers[name].split('.');\n                    const key = obj.pop();\n                    const parentObj = resolveObjectPath(state, obj);\n\n                    // dev errors\n                    if (process.env.NODE_ENV !== 'production') {\n                        // target path must resolve to an array\n                        if (!parentObj || typeof parentObj[key] === 'undefined') {\n                            error(`simpleRemover mutation failed, target \"${mutationName}\" is undefined.`);\n                        } else if (!Array.isArray(parentObj[key])) {\n                            error(`simpleRemover mutation failed, target \"${mutationName}\" is not an array, ${typeof parentObj[key]} found.`);\n                        }\n                    }\n                    \n                    parentObj[key] = parentObj[key].filter(val => val !== removeVal);\n                }\n\n                // otherwise, just remove our value from the array\n                else {\n                    // dev errors\n                    if (process.env.NODE_ENV !== 'production') {\n                        // target must be an array\n                        if (typeof state[mutationName] === 'undefined') {\n                            error(`simpleRemover mutation failed, target \"${mutationName}\" is undefined.`);\n                        } else if (!Array.isArray(state[mutationName])) {\n                            error(`simpleRemover mutation failed, target \"${mutationName}\" is not an array, ${typeof state[mutationName]} found.`);\n                        }\n                    }\n\n                    state[removers[name]] = state[removers[name]].filter(val => val !== removeVal);\n                }\n            },\n        });\n    }, {});\n}\n","import resolveObjectPath from './utils/resolve_object_path';\r\n\r\n/**\r\n * Simple mutations that set a piece of state equal to a value.\r\n *\r\n * @param  {Object} setters     Object mapping mutations to state\r\n * @return {Object}\r\n */\r\nexport default function(setters) {\r\n    // loop over the setter keys and make a mutation for each\r\n    return Object.keys(setters).reduce((mutations, name) => {\r\n\r\n        // attach our new mutation to result\r\n        return Object.assign({}, mutations, {\r\n            [name](state, value) {\r\n\r\n                // if the setter name has a dot, then resolve the\r\n                // state path before feeding our value into it.\r\n                if (setters[name].indexOf('.') > -1) {\r\n                    const obj = setters[name].split('.');\r\n                    const key = obj.pop();\r\n\r\n                    resolveObjectPath(state, obj)[key] = value;\r\n                }\r\n\r\n                // otherwise, just set the state to our value\r\n                else state[setters[name]] = value;\r\n            },\r\n        });\r\n    }, {});\r\n}\r\n"],"names":["stateFactory","state","Object","assign","findInstanceThen","parseArguments","arguments","config","callback","payload","stateAndPayloadAreValid","instance","stateKey","find","obj","instanceKey","bind","opts","args","defaultConfig","Array","isArray","console","error","getters","options","keys","reduce","instanceGetters","name","otherGetters","hasOptionsArg","length","mutations","instanceMutations","defaultOptions","map","key","fns","result","i","apply","call","keyValuePair","value","wrapGetterFn","originalFn","newFn","innerFn","id","invokeGettersWithId","getEntries","toObject","mapInstanceGetters","compose","mapGetters","parseMappingArguments","namespace","mappings","vmIdentifierKey","instanceIdentifierKey","path","delimeter","pathArray","split","p","item","normalizedMappings","normalizeMappings","computedProperties","forEach","computedKey","pop","createGetter","resolveObjectPath","$store","instancesContainer","message","Error","parsedMappings","parseMappings","get","set","createSetter","first","second","mapping","vmKey","slice","lastIndexOf","mutation","commit","setters","findInstance","findValue","indexOf","warn","pushers","mutationName","parentObj","process","env","NODE_ENV","push","removers","removeVal","filter","val"],"mappings":"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"}