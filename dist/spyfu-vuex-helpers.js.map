{"version":3,"file":null,"sources":["../lib/helpers/find_instance_then.js","../lib/helpers/utils/resolve_object_path.js","../lib/helpers/map_two_way_state.js","../lib/helpers/utils/get_entries.js","../lib/helpers/utils/compose.js","../lib/helpers/utils/key_value_to_object.js","../lib/helpers/map_instance_getters.js","../lib/index.js"],"sourcesContent":["/**\n * Find a state instance, and execute a callback if found.\n *\n * @param  {Object|Function}    required    the config object, or mutation callback\n * @param  {Function}           optional    mutation callback\n * @return {Function}\n */\nconst findInstanceThen = function () {\n    // this function supports two argument signatures. if the\n    // first argument is an object, we will use that as the\n    // config, and the second arg as the mutation handler\n    const { config, callback } = parseArguments(arguments);\n\n    return (state, payload) => {\n        if (stateAndPayloadAreValid(config, state, payload)) {\n\n            // find our instance based on the current configuration\n            const instance = state[config.stateKey].find(obj => {\n                return obj[config.instanceKey] === payload[config.instanceKey];\n            });\n\n            // if the instance was found, execute our mutation callback\n            if (instance) {\n                callback(instance, payload, state);\n            }\n        }\n    }\n}\n\n// this method allows us to easily apply configuration to the helper\nfindInstanceThen.config = opts => findInstanceThen.bind(null, opts);\n\n// helper to get config and callback from the arguments\nfunction parseArguments(args) {\n    let defaultConfig = {\n        stateKey: 'instances',\n        instanceKey: 'id',\n    };\n\n    if (typeof args[0] === 'function') {\n        return {\n            callback: args[0],\n            config: defaultConfig,\n        }\n    } else {\n        return {\n            callback: args[1],\n            config: Object.assign({}, defaultConfig, args[0]),\n        };\n    }\n}\n\n// check if the state or payload is malformed\nfunction stateAndPayloadAreValid(config, state, payload) {\n\n    // ensure that the instances array exists\n    if (! Array.isArray(state[config.stateKey])) {\n        console.error(`State does not contain an \"${ config.stateKey }\" array.`);\n        return false;\n    }\n\n    // ensure that the payload contains an id\n    if (typeof payload !== 'object' || typeof payload[config.instanceKey] === 'undefined') {\n        console.error(`Mutation payloads must be an object with an \"${ config.instanceKey }\" property.`);\n        return false;\n    }\n\n    return true;\n}\n\nexport default findInstanceThen;\n","/**\n * Helper function for resolving nested object values.\n *\n * @param  {Object}         obj         source object\n * @param  {String}         path        path to nested value\n * @param  {String|RegExp}  delimeter   characters / pattern to split path on\n * @return {mixed}\n */\nexport default function(obj, path, delimeter = '.') {\n    return path.split(delimeter).reduce((p, item) => p && p[item], obj);\n}\n","import resolveObjectPath from './utils/resolve_object_path';\n\n/**\n * Map vuex state with two way computed properties\n *\n * @param  {string|Object}  required the module namespace, or state mappings\n * @param  {Object}         optional state mappings\n * @return {Object}\n */\nexport default function () {\n    // this function supports two argument signatures. if the\n    // first argument is a string, we will use that as the\n    // namespace, and the next arg as the state mapping\n    const { namespace, mappings } = parseArguments(arguments);\n\n    // then get the key and mutation names from our mappings\n    const parsedMappings = parseMappings(mappings);\n\n    // and last, turn them into getters and setters\n    const computedProperties = {};\n\n    Object.keys(parsedMappings).forEach((key) => {\n        computedProperties[key] = {\n            get: createGetter(namespace, parsedMappings[key]),\n            set: createSetter(namespace, parsedMappings[key]),\n        };\n    });\n\n    return computedProperties;\n}\n\n// determine the values of our namespace and mappings\nfunction parseArguments(args) {\n    const first = args[0];\n    const second = args[1];\n\n    return typeof first === 'string'\n        ? { namespace: first, mappings: second }\n        : { namespace: null, mappings: first };\n}\n\n// determine our key and mutation values\nfunction parseMappings(obj) {\n    const mapping = {};\n\n    Object.keys(obj).forEach((key) => {\n        const value = obj[key];\n        const vmKey = key.slice(key.lastIndexOf('.') + 1);\n\n        if (typeof value === 'string') {\n            mapping[vmKey] = { key, mutation: value };\n        } else {\n            mapping[vmKey] = { key: value.key, mutation: value.mutation };\n        }\n    });\n\n    return mapping;\n}\n\n// create a getter for computed properties\nfunction createGetter(namespace, mapping) {\n    if (namespace) {\n        return function () {\n            const state = resolveObjectPath(this.$store.state, namespace, '/');\n\n            return resolveObjectPath(state, mapping.key, '.');\n        };\n    }\n\n    return function () {\n        return resolveObjectPath(this.$store.state, mapping.key, '.');\n    };\n}\n\n// create a setter for computed properties\nfunction createSetter(namespace, mappings) {\n    let mutation = mappings.mutation;\n\n    if (namespace) {\n        mutation = namespace + '/' + mutation;\n    }\n\n    return function (value) {\n        this.$store.commit(mutation, value)\n    };\n}\n","// Similar to Object.entries but without using polyfill\nexport default function (obj) {\n    return Object.keys(obj).map(key => [ key, obj[key] ]);\n}\n","// Function to compose other functions (right to left evaluation)\nexport default function () {\n    const fns = arguments;\n\n    return function (result) {\n        for (let i = fns.length - 1; i > -1; i--) {\n            result = fns[i].call(this, result);\n        }\n\n        return result;\n    };\n}\n","// Convert KeyValuePair[] to Object\nexport default function (keyValuePairs) {\n    return keyValuePairs.reduce((obj, keyValuePair) => {\n        const [ key, value ] = keyValuePair;\n        obj[key] = value;\n\n        return obj;\n    }, {});\n}\n","import { mapGetters } from 'vuex';\nimport getEntries from './utils/get_entries';\nimport compose from './utils/compose';\nimport toObject from './utils/key_value_to_object';\n\n// Create a wrapper function which invokes the original function\n// passing in `this.id`\nconst wrapGetterFn = ([ key, originalFn ]) => {\n    const newFn = function () {\n        return originalFn(this.id);\n    };\n\n    return [ key, newFn ];\n};\n\nfunction invokeGettersWithId (getters) {\n    return getEntries(getters)\n        .map(wrapGetterFn)\n        .reduce(toObject);\n}\n\nconst mapInstanceGetters = compose(invokeGettersWithId, mapGetters);\n\nexport default mapInstanceGetters;\n","import findInstanceThen from './helpers/find_instance_then';\nimport mapTwoWayState from './helpers/map_two_way_state';\nimport resolveObjectPath from './helpers/utils/resolve_object_path';\nimport mapInstanceGetters from './helpers/map_instance_getters';\n\nmodule.exports = {\n    findInstanceThen,\n    mapTwoWayState,\n    resolveObjectPath,\n    mapInstanceGetters\n};\n"],"names":["findInstanceThen","parseArguments","arguments","config","callback","state","payload","stateAndPayloadAreValid","instance","stateKey","find","obj","instanceKey","bind","opts","args","defaultConfig","Object","assign","Array","isArray","error","path","delimeter","split","reduce","p","item","namespace","mappings","parsedMappings","parseMappings","computedProperties","keys","forEach","key","createGetter","createSetter","first","second","mapping","value","vmKey","slice","lastIndexOf","mutation","resolveObjectPath","$store","commit","map","fns","result","i","length","call","keyValuePairs","keyValuePair","wrapGetterFn","originalFn","newFn","id","invokeGettersWithId","getters","getEntries","toObject","mapInstanceGetters","compose","mapGetters","module","exports"],"mappings":"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"}