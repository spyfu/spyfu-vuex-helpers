{"version":3,"file":"spyfu-vuex-helpers.js","sources":["../lib/helpers/find_instance_then.js","../lib/helpers/instance_mutations.js","../lib/helpers/utils/get_entries.js","../lib/helpers/utils/compose.js","../lib/helpers/utils/key_value_to_object.js","../lib/helpers/map_instance_getters.js","../lib/helpers/utils/parsers.js","../lib/helpers/utils/resolve_object_path.js","../lib/helpers/map_instance_state.js","../lib/helpers/map_two_way_state.js","../lib/helpers/simple_instance_setters.js","../lib/helpers/simple_setters.js"],"sourcesContent":["/**\r\n * Find a state instance, and execute a callback if found.\r\n *\r\n * @param  {Object|Function}    required    the config object, or mutation callback\r\n * @param  {Function}           optional    mutation callback\r\n * @return {Function}\r\n */\r\nconst findInstanceThen = function () {\r\n    // this function supports two argument signatures. if the\r\n    // first argument is an object, we will use that as the\r\n    // config, and the second arg as the mutation handler\r\n    const { config, callback } = parseArguments(arguments);\r\n\r\n    return (state, payload) => {\r\n        if (stateAndPayloadAreValid(config, state, payload)) {\r\n\r\n            // find our instance based on the current configuration\r\n            const instance = state[config.stateKey].find(obj => {\r\n                return obj[config.instanceKey] === payload[config.instanceKey];\r\n            });\r\n\r\n            // if the instance was found, execute our mutation callback\r\n            if (instance) {\r\n                callback(instance, payload, state);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// this method allows us to easily apply configuration to the helper\r\nfindInstanceThen.config = opts => findInstanceThen.bind(null, opts);\r\n\r\n// helper to get config and callback from the arguments\r\nfunction parseArguments(args) {\r\n    let defaultConfig = {\r\n        stateKey: 'instances',\r\n        instanceKey: 'id',\r\n    };\r\n\r\n    if (typeof args[0] === 'function') {\r\n        return {\r\n            callback: args[0],\r\n            config: defaultConfig,\r\n        }\r\n    } else {\r\n        return {\r\n            callback: args[1],\r\n            config: Object.assign({}, defaultConfig, args[0]),\r\n        };\r\n    }\r\n}\r\n\r\n// check if the state or payload is malformed\r\nfunction stateAndPayloadAreValid(config, state, payload) {\r\n\r\n    // ensure that the instances array exists\r\n    if (! Array.isArray(state[config.stateKey])) {\r\n        console.error(`State does not contain an \"${ config.stateKey }\" array.`);\r\n        return false;\r\n    }\r\n\r\n    // ensure that the payload contains an id\r\n    if (typeof payload !== 'object' || typeof payload[config.instanceKey] === 'undefined') {\r\n        console.error(`Mutation payloads must be an object with an \"${ config.instanceKey }\" property.`);\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nexport default findInstanceThen;\r\n","import findInstanceThen from './find_instance_then';\r\n\r\n/**\r\n * Instance mutations.\r\n *\r\n * @return {Object}\r\n */\r\nexport default function() {\r\n    const { options, mutations } = parseArguments(arguments);\r\n\r\n    return Object.keys(mutations).reduce((instanceMutations, name) => {\r\n        instanceMutations[name] = findInstanceThen(options, mutations[name]);\r\n\r\n        return instanceMutations;\r\n    }, {});\r\n}\r\n\r\n// parse arguments\r\nfunction parseArguments(args) {\r\n    const hasOptionsArg = args.length > 1;\r\n\r\n    const defaultOptions = {\r\n        stateKey: 'instances',\r\n        instanceKey: 'id',\r\n    };\r\n\r\n    return {\r\n        options: hasOptionsArg ? args[0] : defaultOptions,\r\n        mutations: hasOptionsArg ? args[1] : args[0],\r\n    };\r\n}\r\n","// Similar to Object.entries but without using polyfill\r\nexport default function (obj) {\r\n    return Object.keys(obj).map(key => [ key, obj[key] ]);\r\n}\r\n","// Function to compose other functions (right to left evaluation)\r\nexport default function () {\r\n    const fns = arguments;\r\n\r\n    return function () {\r\n        let result;\r\n        \r\n        for (let i = fns.length - 1; i > -1; i--) {\r\n            if (i === fns.length - 1) {\r\n                result = fns[i].apply(fns[i], arguments);\r\n            } else {\r\n                result = fns[i].call(this, result);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n}\r\n","// Convert KeyValuePair[] to Object\r\nexport default function (obj, keyValuePair) {\r\n    const [ key, value ] = keyValuePair;\r\n    obj[key] = value;\r\n\r\n    return obj;\r\n}\r\n","import { mapGetters } from 'vuex';\r\nimport getEntries from './utils/get_entries';\r\nimport compose from './utils/compose';\r\nimport toObject from './utils/key_value_to_object';\r\n\r\n// Create a wrapper function which invokes the original function\r\n// passing in `this.id`\r\nconst wrapGetterFn = ([ key, originalFn ]) => {\r\n    const newFn = function () {\r\n        const innerFn = originalFn.apply(this, arguments);\r\n\r\n        if (typeof innerFn !== 'function') {\r\n            /* istanbul ignore next */\r\n            throw `The getter ${key} does not return a function. Try using the 'mapGetter' helper instead`;\r\n        }\r\n        \r\n        return innerFn(this.id);\r\n    };\r\n\r\n    return [ key, newFn ];\r\n};\r\n\r\nfunction invokeGettersWithId (getters) {\r\n    return getEntries(getters)\r\n        .map(wrapGetterFn)\r\n        .reduce(toObject, {});\r\n}\r\n\r\nconst mapInstanceGetters = compose(invokeGettersWithId, mapGetters);\r\n\r\nexport default mapInstanceGetters;\r\n","export function parseMappingArguments(args) {\r\n    // namespace is optional\r\n    const namespace = typeof args[0] === 'string' ? args[0] : null;\r\n\r\n    // mappings are required\r\n    const mappings = namespace ? args[1] : args[0];\r\n\r\n    // by default, the vm identifier key will be 'id'\r\n    const vmIdentifierKey = (namespace ? args[2] : args[1]) || 'id';\r\n\r\n    // by default, the instance identifier will be 'id'\r\n    const stateKey = 'instances';\r\n\r\n    // by default, the state key will be 'instances'\r\n    const instanceIdentifierKey = 'id';\r\n\r\n    return {\r\n        namespace,\r\n        mappings,\r\n        vmIdentifierKey,\r\n        instanceIdentifierKey,\r\n        stateKey,\r\n     };\r\n}\r\n","/**\r\n * Helper function for resolving nested object values.\r\n *\r\n * @param  {Object}         obj         source object\r\n * @param  {Array|String}   path        path to nested value\r\n * @param  {String|RegExp}  delimeter   characters / pattern to split path on\r\n * @return {mixed}\r\n */\r\nexport default function(obj, path, delimeter = '.') {\r\n    const pathArray = Array.isArray(path) ? path : path.split(delimeter);\r\n\r\n    return pathArray.reduce((p, item) => p && p[item], obj);\r\n}\r\n","import { parseMappingArguments } from './utils/parsers';\r\nimport resolveObjectPath from './utils/resolve_object_path';\r\n\r\nexport default function() {\r\n    // extract our namespace and mappings from the arguments\r\n    const {\r\n        namespace,\r\n        mappings,\r\n        vmIdentifierKey,\r\n        instanceIdentifierKey,\r\n        stateKey,\r\n    } = parseMappingArguments(arguments);\r\n\r\n    // normalize our mappings\r\n    const normalizedMappings = normalizeMappings(mappings);\r\n\r\n    // create a getter for each mapped piece of state\r\n    const computedProperties = {};\r\n\r\n    Object.keys(normalizedMappings).forEach((key) => {\r\n        const computedKey = key.split('.').pop();\r\n\r\n        computedProperties[computedKey] = createGetter({\r\n            key,\r\n            namespace,\r\n            normalizedMappings,\r\n            vmIdentifierKey,\r\n            instanceIdentifierKey,\r\n            stateKey,\r\n        });\r\n    });\r\n\r\n    return computedProperties;\r\n}\r\n\r\n// normalize the mappings into a consistent object format\r\nfunction normalizeMappings(mappings) {\r\n    if (Array.isArray(mappings)) {\r\n        return mappings.reduce((normalizedMappings, key) => {\r\n            normalizedMappings[key] = key;\r\n\r\n            return normalizedMappings;\r\n        }, {});\r\n    }\r\n\r\n    return mappings;\r\n}\r\n\r\n// create a getter for a particular piece of state\r\nfunction createGetter({ key, namespace, normalizedMappings, vmIdentifierKey, instanceIdentifierKey, stateKey }) {\r\n    return function() {\r\n        // find the state object\r\n        const state = namespace\r\n            ? resolveObjectPath(this.$store.state, namespace, '/')\r\n            : this.$store.state;\r\n\r\n        // find our container of instances\r\n        const instancesContainer = resolveObjectPath(state, stateKey, '.');\r\n\r\n        // find our instance within it\r\n        const instance = instancesContainer.find(obj => obj[instanceIdentifierKey] === this[vmIdentifierKey]);\r\n\r\n        // and if all goes well, resolve the piece of state we're looking for\r\n        if (instance) {\r\n            return typeof normalizedMappings[key] === 'function'\r\n                ? normalizedMappings[key](instance)\r\n                : resolveObjectPath(instance, normalizedMappings[key]);\r\n        }\r\n    }\r\n}\r\n","import resolveObjectPath from './utils/resolve_object_path';\r\n\r\n/**\r\n * Map vuex state with two way computed properties\r\n *\r\n * @param  {string|Object}  required the module namespace, or state mappings\r\n * @param  {Object}         optional state mappings\r\n * @return {Object}\r\n */\r\nexport default function () {\r\n    // this function supports two argument signatures. if the\r\n    // first argument is a string, we will use that as the\r\n    // namespace, and the next arg as the state mapping\r\n    const { namespace, mappings } = parseArguments(arguments);\r\n\r\n    // then get the key and mutation names from our mappings\r\n    const parsedMappings = parseMappings(mappings);\r\n\r\n    // and last, turn them into getters and setters\r\n    const computedProperties = {};\r\n\r\n    Object.keys(parsedMappings).forEach((key) => {\r\n        computedProperties[key] = {\r\n            get: createGetter(namespace, parsedMappings[key]),\r\n            set: createSetter(namespace, parsedMappings[key]),\r\n        };\r\n    });\r\n\r\n    return computedProperties;\r\n}\r\n\r\n// determine the values of our namespace and mappings\r\nfunction parseArguments(args) {\r\n    const first = args[0];\r\n    const second = args[1];\r\n\r\n    return typeof first === 'string'\r\n        ? { namespace: first, mappings: second }\r\n        : { namespace: null, mappings: first };\r\n}\r\n\r\n// determine our key and mutation values\r\nfunction parseMappings(obj) {\r\n    const mapping = {};\r\n\r\n    Object.keys(obj).forEach((key) => {\r\n        const value = obj[key];\r\n        const vmKey = key.slice(key.lastIndexOf('.') + 1);\r\n\r\n        if (typeof value === 'string') {\r\n            mapping[vmKey] = { key, mutation: value };\r\n        } else {\r\n            mapping[vmKey] = { key: value.key, mutation: value.mutation };\r\n        }\r\n    });\r\n\r\n    return mapping;\r\n}\r\n\r\n// create a getter for computed properties\r\nfunction createGetter(namespace, mapping) {\r\n    if (namespace) {\r\n        return function () {\r\n            const state = resolveObjectPath(this.$store.state, namespace, '/');\r\n\r\n            return resolveObjectPath(state, mapping.key, '.');\r\n        };\r\n    }\r\n\r\n    return function () {\r\n        return resolveObjectPath(this.$store.state, mapping.key, '.');\r\n    };\r\n}\r\n\r\n// create a setter for computed properties\r\nfunction createSetter(namespace, mappings) {\r\n    let mutation = mappings.mutation;\r\n\r\n    if (namespace) {\r\n        mutation = namespace + '/' + mutation;\r\n    }\r\n\r\n    return function (value) {\r\n        this.$store.commit(mutation, value)\r\n    };\r\n}\r\n","import resolveObjectPath from './utils/resolve_object_path';\r\n\r\n/**\r\n * Simple mutations that set an instance's state equal to a value.\r\n *\r\n * @param  {Object}\r\n * @param  {String}\r\n * @param  {String}\r\n * @return {Object}\r\n */\r\nexport default function(\r\n    setters,\r\n    stateKey = 'instances',\r\n    instanceKey = 'id'\r\n) {\r\n    // loop over the setter keys and make a mutation for each\r\n    return Object.keys(setters).reduce((mutations, name) => {\r\n\r\n        // attach our new mutation to result\r\n        return Object.assign({}, mutations, {\r\n            [name](state, payload) {\r\n                // find the instance that we're mutating\r\n                const instance = findInstance(state, stateKey, instanceKey, payload);\r\n\r\n                if (instance) {\r\n                    const value = findValue(payload, instanceKey);\r\n\r\n                    // if the setter name has a dot, then resolve the\r\n                    // state path before feeding our value into it.\r\n                    if (setters[name].indexOf('.') > -1) {\r\n                        const obj = setters[name].split('.');\r\n                        const key = obj.pop();\r\n\r\n                        resolveObjectPath(instance, obj)[key] = value;\r\n                    } else {\r\n                        // otherwise, just set the instance state to our value\r\n                        instance[setters[name]] = value;\r\n                    }\r\n                } else {\r\n                    // if the instance wasn't found, let the dev know with a warning\r\n                    console.warn (`An instance with an identifier of ${instanceKey} was not found.`);\r\n                }\r\n            },\r\n        });\r\n    }, {});\r\n}\r\n\r\n// helper function to find the correct instance\r\nfunction findInstance(state, stateKey, instanceKey, payload) {\r\n    return state[stateKey].find(obj => obj[instanceKey] === payload[instanceKey]);\r\n}\r\n\r\n// helper function to find the payload value\r\nfunction findValue(payload, instanceKey) {\r\n    for (let key in payload) {\r\n        if (key !== instanceKey) {\r\n            return payload[key];\r\n        }\r\n    }\r\n\r\n    // if we don't have a value, throw an error because the payload is invalid.\r\n    /* istanbul ignore next */\r\n    throw new Error('Failed to mutate instance, no value found in payload.', payload);\r\n}\r\n","import resolveObjectPath from './utils/resolve_object_path';\r\n\r\n/**\r\n * Simple mutations that set a piece of state equal to a value.\r\n *\r\n * @param  {Object} setters     Object mapping mutations to state\r\n * @return {Object}\r\n */\r\nexport default function(setters) {\r\n    // loop over the setter keys and make a mutation for each\r\n    return Object.keys(setters).reduce((mutations, name) => {\r\n\r\n        // attach our new mutation to result\r\n        return Object.assign({}, mutations, {\r\n            [name](state, value) {\r\n\r\n                // if the setter name has a dot, then resolve the\r\n                // state path before feeding our value into it.\r\n                if (setters[name].indexOf('.') > -1) {\r\n                    const obj = setters[name].split('.');\r\n                    const key = obj.pop();\r\n\r\n                    resolveObjectPath(state, obj)[key] = value;\r\n                }\r\n\r\n                // otherwise, just set the state to our value\r\n                else state[setters[name]] = value;\r\n            },\r\n        });\r\n    }, {});\r\n}\r\n"],"names":["findInstanceThen","parseArguments","arguments","config","callback","state","payload","stateAndPayloadAreValid","instance","stateKey","find","obj","instanceKey","bind","opts","args","defaultConfig","Object","assign","Array","isArray","error","options","mutations","keys","reduce","instanceMutations","name","hasOptionsArg","length","defaultOptions","map","key","fns","result","i","apply","call","keyValuePair","value","wrapGetterFn","originalFn","newFn","innerFn","id","invokeGettersWithId","getters","getEntries","toObject","mapInstanceGetters","compose","mapGetters","parseMappingArguments","namespace","mappings","vmIdentifierKey","instanceIdentifierKey","path","delimeter","pathArray","split","p","item","normalizedMappings","normalizeMappings","computedProperties","forEach","computedKey","pop","createGetter","resolveObjectPath","$store","instancesContainer","parsedMappings","parseMappings","createSetter","first","second","mapping","vmKey","slice","lastIndexOf","mutation","commit","setters","findInstance","findValue","indexOf","warn","Error"],"mappings":"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"}