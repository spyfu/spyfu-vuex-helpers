{"version":3,"file":null,"sources":["../lib/helpers/find_instance_then.js","../lib/helpers/map_two_way_state.js","../lib/index.js"],"sourcesContent":["/**\r\n * Find a state instance, and execute a callback if found.\r\n *\r\n * @param  {Function} callback\r\n * @return {Function}\r\n */\r\nexport default function (callback) {\r\n    return (state, payload) => {\r\n        const instance = state.instances.find(obj => obj.id === payload.id);\r\n\r\n        if (instance) {\r\n            callback(instance, payload, state);\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Map vuex state with two way computed properties\r\n *\r\n * @param  {string|Object}  required the module namespace, or state mappings\r\n * @param  {Object}         optional state mappings\r\n * @return {Object}\r\n */\r\nexport default function () {\r\n    // this function supports two argument signatures. if the\r\n    // first argument is a string, we will use that as the\r\n    // namespace, and the next arg as the state mapping\r\n    const { namespace, mappings } = parseArguments(arguments);\r\n\r\n    // then get the key and mutation names from our mappings\r\n    const parsedMappings = parseMappings(mappings);\r\n\r\n    // and last, turn them into getters and setters\r\n    const computedProperties = {};\r\n\r\n    Object.keys(parsedMappings).forEach((key) => {\r\n        computedProperties[key] = {\r\n            get: createGetter(namespace, parsedMappings[key]),\r\n            set: createSetter(namespace, parsedMappings[key]),\r\n        };\r\n    });\r\n\r\n    return computedProperties;\r\n}\r\n\r\n// determine the values of our namespace and mappings\r\nfunction parseArguments(args) {\r\n    const first = args[0];\r\n    const second = args[1];\r\n\r\n    return typeof first === 'string'\r\n        ? { namespace: first, mappings: second }\r\n        : { namespace: null, mappings: first };\r\n}\r\n\r\n// determine our key and mutation values\r\nfunction parseMappings(obj) {\r\n    const mapping = {};\r\n\r\n    Object.keys(obj).forEach((key) => {\r\n        const value = obj[key];\r\n        const vmKey = key.slice(key.lastIndexOf('.') + 1);\r\n\r\n        if (typeof value === 'string') {\r\n            mapping[vmKey] = { key, mutation: value };\r\n        } else {\r\n            mapping[vmKey] = { key: value.key, mutation: value.mutation };\r\n        }\r\n    });\r\n\r\n    return mapping;\r\n}\r\n\r\n// resolve an object path from a string\r\nfunction resolveObject(obj, path, delimeter) {\r\n    return path.split(delimeter).reduce((p, item) => p && p[item], obj);\r\n}\r\n\r\n// create a getter for computed properties\r\nfunction createGetter(namespace, mapping) {\r\n    if (namespace) {\r\n        return function () {\r\n            const state = resolveObject(this.$store.state, namespace, '/');\r\n\r\n            return resolveObject(state, mapping.key, '.');\r\n        };\r\n    }\r\n\r\n    return function () {\r\n        return resolveObject(this.$store.state, mapping.key, '.');\r\n    };\r\n}\r\n\r\n// create a setter for computed properties\r\nfunction createSetter(namespace, mappings) {\r\n    let mutation = mappings.mutation;\r\n\r\n    if (namespace) {\r\n        mutation = namespace + '/' + mutation;\r\n    }\r\n\r\n    return function (value) {\r\n        this.$store.commit(mutation, value)\r\n    };\r\n}\r\n","import findInstanceThen from './helpers/find_instance_then';\r\nimport mapTwoWayState from './helpers/map_two_way_state';\r\n\r\nmodule.exports = {\r\n    findInstanceThen,\r\n    mapTwoWayState,\r\n}\r\n"],"names":["callback","state","payload","instance","instances","find","obj","id","parseArguments","arguments","namespace","mappings","parsedMappings","parseMappings","computedProperties","keys","forEach","key","createGetter","createSetter","args","first","second","mapping","value","vmKey","slice","lastIndexOf","mutation","resolveObject","path","delimeter","split","reduce","p","item","$store","commit","module","exports"],"mappings":"AAAA;;;;;;AAMA,uBAAe,UAAUA,QAAV,EAAoB;WACxB,UAACC,KAAD,EAAQC,OAAR,EAAoB;YACjBC,WAAWF,MAAMG,SAAN,CAAgBC,IAAhB,CAAqB;mBAAOC,IAAIC,EAAJ,KAAWL,QAAQK,EAA1B;SAArB,CAAjB;;YAEIJ,QAAJ,EAAc;qBACDA,QAAT,EAAmBD,OAAnB,EAA4BD,KAA5B;;KAJR;;;ACPJ;;;;;;;AAOA,qBAAe,YAAY;;;;0BAISO,eAAeC,SAAf,CAJT;QAIfC,SAJe,mBAIfA,SAJe;QAIJC,QAJI,mBAIJA,QAJI;;;;;QAOjBC,iBAAiBC,cAAcF,QAAd,CAAvB;;;QAGMG,qBAAqB,EAA3B;;WAEOC,IAAP,CAAYH,cAAZ,EAA4BI,OAA5B,CAAoC,UAACC,GAAD,EAAS;2BACtBA,GAAnB,IAA0B;iBACjBC,aAAaR,SAAb,EAAwBE,eAAeK,GAAf,CAAxB,CADiB;iBAEjBE,aAAaT,SAAb,EAAwBE,eAAeK,GAAf,CAAxB;SAFT;KADJ;;WAOOH,kBAAP;;;;AAIJ,SAASN,cAAT,CAAwBY,IAAxB,EAA8B;QACpBC,QAAQD,KAAK,CAAL,CAAd;QACME,SAASF,KAAK,CAAL,CAAf;;WAEO,OAAOC,KAAP,KAAiB,QAAjB,GACD,EAAEX,WAAWW,KAAb,EAAoBV,UAAUW,MAA9B,EADC,GAED,EAAEZ,WAAW,IAAb,EAAmBC,UAAUU,KAA7B,EAFN;;;;AAMJ,SAASR,aAAT,CAAuBP,GAAvB,EAA4B;QAClBiB,UAAU,EAAhB;;WAEOR,IAAP,CAAYT,GAAZ,EAAiBU,OAAjB,CAAyB,UAACC,GAAD,EAAS;YACxBO,QAAQlB,IAAIW,GAAJ,CAAd;YACMQ,QAAQR,IAAIS,KAAJ,CAAUT,IAAIU,WAAJ,CAAgB,GAAhB,IAAuB,CAAjC,CAAd;;YAEI,OAAOH,KAAP,KAAiB,QAArB,EAA+B;oBACnBC,KAAR,IAAiB,EAAER,QAAF,EAAOW,UAAUJ,KAAjB,EAAjB;SADJ,MAEO;oBACKC,KAAR,IAAiB,EAAER,KAAKO,MAAMP,GAAb,EAAkBW,UAAUJ,MAAMI,QAAlC,EAAjB;;KAPR;;WAWOL,OAAP;;;;AAIJ,SAASM,aAAT,CAAuBvB,GAAvB,EAA4BwB,IAA5B,EAAkCC,SAAlC,EAA6C;WAClCD,KAAKE,KAAL,CAAWD,SAAX,EAAsBE,MAAtB,CAA6B,UAACC,CAAD,EAAIC,IAAJ;eAAaD,KAAKA,EAAEC,IAAF,CAAlB;KAA7B,EAAwD7B,GAAxD,CAAP;;;;AAIJ,SAASY,YAAT,CAAsBR,SAAtB,EAAiCa,OAAjC,EAA0C;QAClCb,SAAJ,EAAe;eACJ,YAAY;gBACTT,QAAQ4B,cAAc,KAAKO,MAAL,CAAYnC,KAA1B,EAAiCS,SAAjC,EAA4C,GAA5C,CAAd;;mBAEOmB,cAAc5B,KAAd,EAAqBsB,QAAQN,GAA7B,EAAkC,GAAlC,CAAP;SAHJ;;;WAOG,YAAY;eACRY,cAAc,KAAKO,MAAL,CAAYnC,KAA1B,EAAiCsB,QAAQN,GAAzC,EAA8C,GAA9C,CAAP;KADJ;;;;AAMJ,SAASE,YAAT,CAAsBT,SAAtB,EAAiCC,QAAjC,EAA2C;QACnCiB,WAAWjB,SAASiB,QAAxB;;QAEIlB,SAAJ,EAAe;mBACAA,YAAY,GAAZ,GAAkBkB,QAA7B;;;WAGG,UAAUJ,KAAV,EAAiB;aACfY,MAAL,CAAYC,MAAZ,CAAmBT,QAAnB,EAA6BJ,KAA7B;KADJ;;;AClFJc,OAAOC,OAAP,GAAiB;sCAAA;;CAAjB"}