{"version":3,"file":null,"sources":["../lib/helpers/map_two_way_state.js","../lib/index.js"],"sourcesContent":["/**\r\n * Map vuex state with two way computed properties\r\n *\r\n * @param  {string|Object}  required the module namespace, or state mappings\r\n * @param  {Object}         optional state mappings\r\n * @return {Object}\r\n */\r\nexport default function () {\r\n    // this function supports two argument signatures. if the\r\n    // first argument is a string, we will use that as the\r\n    // namespace, and the next arg as the state mapping\r\n    const { namespace, mappings } = parseArguments(arguments);\r\n\r\n    // then get the key and mutation names from our mappings\r\n    const parsedMappings = parseMappings(mappings);\r\n\r\n    // and last, turn them into getters and setters\r\n    const computedProperties = {};\r\n\r\n    Object.keys(parsedMappings).forEach((key) => {\r\n        computedProperties[key] = {\r\n            get: createGetter(namespace, parsedMappings[key]),\r\n            set: createSetter(namespace, parsedMappings[key]),\r\n        };\r\n    });\r\n\r\n    return computedProperties;\r\n}\r\n\r\n// determine the values of our namespace and mappings\r\nfunction parseArguments(args) {\r\n    const first = args[0];\r\n    const second = args[1];\r\n\r\n    return typeof first === 'string'\r\n        ? { namespace: first, mappings: second }\r\n        : { namespace: null, mappings: first };\r\n}\r\n\r\n// determine our key and mutation values\r\nfunction parseMappings(obj) {\r\n    const map = {};\r\n\r\n    Object.keys(obj).forEach((key) => {\r\n        const value = obj[key];\r\n\r\n        if (typeof value === 'string') {\r\n            map[key] = { key, mutation: value };\r\n        } else {\r\n            map[key] = { key: value.key, mutation: value.mutation };\r\n        }\r\n    });\r\n\r\n    return map;\r\n}\r\n\r\n// create a getter for computed properties\r\nfunction createGetter(namespace, mapping) {\r\n    if (namespace) {\r\n        return function () {\r\n            return this.$store.state[namespace][mapping.key];\r\n        };\r\n    }\r\n\r\n    return function () {\r\n        return this.$store.state[mapping.key];\r\n    };\r\n}\r\n\r\n// create a setter for computed properties\r\nfunction createSetter(namespace, mappings) {\r\n    let mutation = mappings.mutation;\r\n\r\n    if (namespace) {\r\n        mutation = namespace + '/' + mutation;\r\n    }\r\n\r\n    return function (value) {\r\n        this.$store.commit(mutation, value)\r\n    };\r\n}\r\n","import mapTwoWayState from './helpers/map_two_way_state';\r\n\r\nmodule.exports = {\r\n    mapTwoWayState,\r\n}\r\n"],"names":["parseArguments","args","first","second","namespace","mappings","parseMappings","obj","map","keys","forEach","key","value","mutation","createGetter","mapping","this","$store","state","createSetter","commit","arguments","parsedMappings","computedProperties","module","exports"],"mappings":"AA8BA,SAASA,eAAeC,OACdC,EAAQD,EAAK,GACbE,EAASF,EAAK,SAEI,iBAAVC,GACNE,UAAWF,EAAOG,SAAUF,IAC5BC,UAAW,KAAMC,SAAUH,GAIvC,SAASI,cAAcC,OACbC,mBAECC,KAAKF,GAAKG,QAAQ,SAACC,OAChBC,EAAQL,EAAII,KAGVA,GADa,iBAAVC,GACMD,MAAKE,SAAUD,IAEfD,IAAKC,EAAMD,IAAKE,SAAUD,EAAMC,YAI9CL,EAIX,SAASM,aAAaV,EAAWW,UACzBX,EACO,kBACIY,KAAKC,OAAOC,MAAMd,GAAWW,EAAQJ,MAI7C,kBACIK,KAAKC,OAAOC,MAAMH,EAAQJ,MAKzC,SAASQ,aAAaf,EAAWC,OACzBQ,EAAWR,EAASQ,gBAEpBT,MACWA,EAAY,IAAMS,GAG1B,SAAUD,QACRK,OAAOG,OAAOP,EAAUD,IAvErC,mBAAe,iBAIqBZ,eAAeqB,WAAvCjB,IAAAA,UAGFkB,EAAiBhB,gBAHJD,UAMbkB,mBAECd,KAAKa,GAAgBZ,QAAQ,SAACC,KACdA,QACVG,aAAaV,EAAWkB,EAAeX,QACvCQ,aAAaf,EAAWkB,EAAeX,OAI7CY,GCxBXC,OAAOC"}