{"version":3,"file":null,"sources":["../lib/helpers/map_two_way_state.js","../lib/index.js"],"sourcesContent":["/**\r\n * Map vuex state with two way computed properties\r\n *\r\n * @param  {string|Object}  required the module namespace, or state mappings\r\n * @param  {Object}         optional state mappings\r\n * @return {Object}\r\n */\r\nexport default function () {\r\n\r\n    // this function supports two different argument signatures. if the\r\n    // first argument is a string, we'll use the first argument as a\r\n    // namespace, and the second argument as your state mappings.\r\n    const { namespace, mappings } = parseArguments(arguments);\r\n\r\n    // then we will get the key and mutation names from our mapping.\r\n    const parsedMappings = parseMappings(mappings);\r\n\r\n    // then turn them into getters and setters for computed properties.\r\n    const computedProperties = {};\r\n\r\n    Object.keys(parsedMappings).forEach((key) => {\r\n        computedProperties[key] = {\r\n            get: createGetter(namespace, mappings[key]),\r\n            set: createSetter(namespace, mappings[key]),\r\n        };\r\n    });\r\n\r\n    return computedProperties;\r\n}\r\n\r\n// determine the values of our namespace and mappings\r\nfunction parseArguments(first, second) {\r\n    return typeof first === 'string'\r\n        ? { namespace: first, mappings: second }\r\n        : { namespace: null, mappings: first };\r\n}\r\n\r\n// determine our key and mutation values\r\nfunction parseMappings(obj) {\r\n    const map = {};\r\n\r\n    Object.keys(obj).forEach((key) => {\r\n        const value = obj[key];\r\n\r\n        if (typeof value === 'string') {\r\n            map[key] = { key, mutation: value };\r\n        } else {\r\n            map[key] = { key: value.key, mutation: value.mutation };\r\n        }\r\n    });\r\n\r\n    return map;\r\n}\r\n\r\n// create a getter for computed properties\r\nfunction createGetter(namespace, mapping) {\r\n    if (typeof namespace === 'string') {\r\n        return function set() {\r\n            return this.$store.state[namespace][mapping.key];\r\n        };\r\n    }\r\n\r\n    return function set() {\r\n        return this.$store.state[mapping.key];\r\n    };\r\n}\r\n\r\n// create a setter for computed properties\r\nfunction createSetter(namespace, mappings) {\r\n    let mutation = mappings.mutation;\r\n\r\n    if (typeof namespace === 'string') {\r\n        mutation = namespace + '/' + mutation;\r\n    }\r\n\r\n    return function set (value) {\r\n        this.$store.commit(mutation, value)\r\n    }\r\n}\r\n","import mapTwoWayState from './helpers/map_two_way_state';\r\n\r\nmodule.exports = {\r\n    mapTwoWayState,\r\n}\r\n"],"names":["parseArguments","first","second","namespace","mappings","parseMappings","obj","map","keys","forEach","key","value","mutation","createGetter","mapping","this","$store","state","createSetter","commit","arguments","parsedMappings","computedProperties","module","exports"],"mappings":"AA+BA,SAASA,eAAeC,EAAOC,SACH,iBAAVD,GACNE,UAAWF,EAAOG,SAAUF,IAC5BC,UAAW,KAAMC,SAAUH,GAIvC,SAASI,cAAcC,OACbC,mBAECC,KAAKF,GAAKG,QAAQ,SAACC,OAChBC,EAAQL,EAAII,KAGVA,GADa,iBAAVC,GACMD,MAAKE,SAAUD,IAEfD,IAAKC,EAAMD,IAAKE,SAAUD,EAAMC,YAI9CL,EAIX,SAASM,aAAaV,EAAWW,SACJ,iBAAdX,EACA,kBACIY,KAAKC,OAAOC,MAAMd,GAAWW,EAAQJ,MAI7C,kBACIK,KAAKC,OAAOC,MAAMH,EAAQJ,MAKzC,SAASQ,aAAaf,EAAWC,OACzBQ,EAAWR,EAASQ,eAEC,iBAAdT,MACIA,EAAY,IAAMS,GAG1B,SAAcD,QACZK,OAAOG,OAAOP,EAAUD,IArErC,mBAAe,iBAKqBX,eAAeoB,WAAvCjB,IAAAA,UAAWC,IAAAA,SAGbiB,EAAiBhB,cAAcD,GAG/BkB,mBAECd,KAAKa,GAAgBZ,QAAQ,SAACC,KACdA,QACVG,aAAaV,EAAWC,EAASM,QACjCQ,aAAaf,EAAWC,EAASM,OAIvCY,GCzBXC,OAAOC"}